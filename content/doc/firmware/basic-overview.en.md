---
title: "Basic Overview"
menu:
  doc:
    parent: 'firmware'
    weight: 10
---

You can compile and flash your own code to the Core Module. To do that you need to install [**BigClown toolchain**]({{< relref "/doc/firmware/toolchain-setup.en.md" >}}) to your computer, or you can compile code also on **Raspberry Pi** with our [**bc-raspbian**]({{<relref "/doc/tutorials/raspberry-pi-installation.en.md">}}) image and installing the [**GCC package**](https://forum.bigclown.com/t/how-to-compile-bigclown-firmware-on-raspberry-pi/271/10?u=hub.martin)

Toolchain comes with many useful tools, please see the **Tools** section in the menu where tools like [**bcf**]({{< relref "/doc/tools/bcf.en.md" >}}) are explained.

Every BigClown Module has its own library in the [**BigClown SDK**](https://sdk.bigclown.com/). So you just call **init** function and set the **callback** function.

In this section you will find code examples for **Core Module** and all the other **BigClown Modules**. More example code can be found in the GitHub [**sdk/_examples**](https://github.com/bigclownlabs/bcf-sdk/tree/master/_examples) folder.

## Firmware flashing

With these tools you can flash new firmware. Tools can automatically download pre-compiled firmwares from GitHub and you can also choose your own `*.bin` file to flash.

* [**BigClown Playground**]({{< relref "/doc/projects/radio-door-sensor.en.md#flash-door-sensor-firmware" >}}) is a GUI multi-platform tool.
* [**BigClown Flasher**]({{< relref "/doc/tools/bcf.en.md" >}}) (`bcf`) command line tool.

## Example Code

Toggling an LED on button press with the **SDK** is as easy as this code snippet:

```c
#include <application.h>

// LED instance
bc_led_t led;

// Button instance
bc_button_t button;

void button_event_handler(bc_button_t *self, bc_button_event_t event, void *event_param)
{
    if (event == BC_BUTTON_EVENT_PRESS)
    {
        bc_led_set_mode(&led, BC_LED_MODE_TOGGLE);
    }
}

void application_init(void)
{
    // Initialize LED
    bc_led_init(&led, BC_GPIO_LED, false, false);
    bc_led_set_mode(&led, BC_LED_MODE_ON);

    // Initialize button
    bc_button_init(&button, BC_GPIO_BUTTON, BC_GPIO_PULL_DOWN, false);
    bc_button_set_event_handler(&button, button_event_handler, NULL);
}
```

## Programming Language

Firmware is implemented in pure **C language**, which is industrially accepted language for embedded and low-power devices. There are the main reasons for choosing this technology:

* Effecient use of hardware resources
* Stability and long time available development environment
* Simple and understandable syntax

{{% note "info" %}}Effective use of hardware resources is important for developing of low-power devices. This is primary goal of BigClown ecosystem.{{% /note %}}

You can choose from wide variety of systems and tools. Windows, macOS a Ubuntu (and other Debian derivatives) are supported. For information how to install required tools, please see [**Toolchain setup**]({{< relref "/doc/firmware/toolchain-setup.en.md">}}). You can find more information on how to use them in [**Toolchain guide**]({{< relref "/doc/firmware/toolchain-guide.en.md">}}).

## Diving Deep to SDK

Basic pillar of every BigClown (software) project is an ecosystem of libraries, drivers and header files, the so-called **BigClown SDK** (which stands for [**Software Development Kit**](https://en.wikipedia.org/wiki/Software_development_kit).

It can be found in this repository:

**https://github.com/bigclownlabs/bc-core-module-sdk**

The header files include documentation, that can be generated by **Doxygen**. You can find the most recent version of the generated documentation here:

[**https://sdk.bigclown.com/**](https://sdk.bigclown.com/)

We try to stick to these principles while working the **SDK** development:

* Consistent and clear API design

* Modular and object oriented approach

* We prefer asynchronous, event-driven programming

* Well-named functions, data types, variables, etc.

* Simple way of access to low level hardware

## SDK Integration

To your project, SDK is integrated as a **Git Submodule**. This has one advantage - your firmware can be "linked and locked" to a specific version of the **SDK**. This makes sure that it will be possible to compile your firmware at any time in the future. But if you need to, the **SDK** can be updated to most recent version by simple `make update` command.

{{% note "danger" %}}Please DO NOT integrate the **SDK** to your project as files extracted from the downloaded ZIP file from GitHub. Although this will work and firmware will compile, for getting technical support you will have to provide the exact version of the **SDK** used (a commit hash).{{% /note %}}
